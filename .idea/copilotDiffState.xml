<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/NETLIFY_FIX.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/NETLIFY_FIX.md" />
              <option name="updatedContent" value="# Netlify Environment Detection Fix&#10;&#10;## Problem&#10;The error `ENOENT: no such file or directory, open '/var/task/data/program.json'` occurred because:&#10;&#10;1. The code was trying to use the file system on Netlify's serverless environment&#10;2. The `process.env.NETLIFY` check wasn't working correctly&#10;3. The `/var/task/` directory is read-only on Netlify serverless functions&#10;&#10;## Solution Applied&#10;&#10;### 1. Enhanced Environment Detection&#10;Updated all API routes to detect Netlify environment more reliably:&#10;&#10;```typescript&#10;const isNetlify = process.env.NETLIFY === 'true' || &#10;                  process.env.NETLIFY_DEV === 'true' ||&#10;                  !!process.env.NETLIFY_BUILD_BASE ||&#10;                  process.env.CONTEXT !== undefined;&#10;```&#10;&#10;### 2. Fallback Logic&#10;Added try-catch blocks to gracefully fall back to file system if Netlify Blobs fails:&#10;&#10;- **Production/Netlify**: Try Netlify Blobs first&#10;- **If Blobs fails**: Fall back to file system (for local dev)&#10;- **Better error logging**: Track which storage method is being used&#10;&#10;### 3. Files Updated&#10;- ✅ `app/api/update-program/route.ts` - Enhanced detection + fallback&#10;- ✅ `app/api/get-program/route.ts` - Enhanced detection + fallback  &#10;- ✅ `app/api/upload-image/route.ts` - Enhanced detection + fallback&#10;&#10;## Verification Steps&#10;&#10;After deploying these changes:&#10;&#10;1. **Check Netlify Function Logs** for environment detection:&#10;   ```&#10;   Environment check: {&#10;     NETLIFY: 'true',&#10;     CONTEXT: 'production',&#10;     isNetlify: true&#10;   }&#10;   ```&#10;&#10;2. **Verify Blobs are being used**:&#10;   ```&#10;   Attempting to use Netlify Blobs&#10;   Successfully saved to Netlify Blobs&#10;   ```&#10;&#10;3. **Test Admin Portal**:&#10;   - Log in to `/admin`&#10;   - Update a program&#10;   - Upload an image&#10;   - Verify changes appear on main site&#10;&#10;## How Netlify Blobs Work&#10;&#10;### Storage&#10;- **Programs**: Stored in `programs` store as `current-program` key&#10;- **Images**: Stored in `program-images` store with timestamped filenames&#10;&#10;### Access&#10;- **Read**: `await store.get(&quot;current-program&quot;, { type: &quot;json&quot; })`&#10;- **Write**: `await store.set(&quot;current-program&quot;, JSON.stringify(data))`&#10;&#10;### Limits (Free Tier)&#10;- 1 GB storage&#10;- 1 million reads per month&#10;- 100,000 writes per month&#10;&#10;## Troubleshooting&#10;&#10;### If Blobs Still Fail&#10;&#10;1. **Check Netlify Blobs is enabled**:&#10;   - Go to Netlify Dashboard → Site Settings → Blobs&#10;   - Ensure it's enabled for your site&#10;&#10;2. **Verify @netlify/blobs package**:&#10;   ```bash&#10;   npm list @netlify/blobs&#10;   ```&#10;   Should show version 7.x or higher&#10;&#10;3. **Check Function Logs**:&#10;   - Go to Netlify Dashboard → Functions&#10;   - Look for error messages in logs&#10;&#10;4. **Manual Blob Creation**:&#10;   You can manually create initial data via Netlify CLI:&#10;   ```bash&#10;   netlify blobs:set current-program '{&quot;currentWeek&quot;:null,&quot;previousWeeks&quot;:[]}' --store programs&#10;   ```&#10;&#10;### If File System Errors Persist&#10;&#10;The fallback to file system won't work on Netlify serverless (read-only). If you see this:&#10;- Blobs must be properly configured&#10;- Check that `@netlify/blobs` is in `dependencies` (not `devDependencies`)&#10;- Redeploy after ensuring Blobs are enabled&#10;&#10;## Environment Variables&#10;&#10;Netlify automatically sets these in production:&#10;- `NETLIFY=true`&#10;- `CONTEXT=production` (or `deploy-preview`, `branch-deploy`)&#10;- `NETLIFY_BUILD_BASE=/opt/build/repo`&#10;&#10;You don't need to manually set these.&#10;&#10;## Next Steps&#10;&#10;1. **Commit and push** the updated code:&#10;   ```bash&#10;   git add .&#10;   git commit -m &quot;Fix: Improve Netlify environment detection and add Blobs fallback&quot;&#10;   git push&#10;   ```&#10;&#10;2. **Monitor the deployment** in Netlify dashboard&#10;&#10;3. **Check function logs** to verify Blobs are being used&#10;&#10;4. **Test the admin portal** thoroughly&#10;&#10;---&#10;&#10;**Fixed**: November 7, 2025  &#10;**Issue**: ENOENT file system errors on Netlify  &#10;**Solution**: Enhanced environment detection + Netlify Blobs integration&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/get-program/route.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/get-program/route.ts" />
              <option name="originalContent" value="import { NextResponse } from &quot;next/server&quot;;&#10;import { promises as fs } from &quot;fs&quot;;&#10;import path from &quot;path&quot;;&#10;&#10;export async function GET() {&#10;  try {&#10;    // In production on Netlify, use Netlify Blobs via function&#10;    if (process.env.NETLIFY) {&#10;      const { getStore } = await import(&quot;@netlify/blobs&quot;);&#10;      const store = getStore(&quot;programs&quot;);&#10;      const programData = await store.get(&quot;current-program&quot;, { type: &quot;json&quot; });&#10;&#10;      if (!programData) {&#10;        return NextResponse.json({&#10;          currentWeek: null,&#10;          previousWeeks: [],&#10;        });&#10;      }&#10;&#10;      return NextResponse.json(programData);&#10;    }&#10;&#10;    // For local development, use file system&#10;    const dataPath = path.join(process.cwd(), &quot;data&quot;, &quot;program.json&quot;);&#10;&#10;    try {&#10;      const fileContent = await fs.readFile(dataPath, &quot;utf-8&quot;);&#10;      const programData = JSON.parse(fileContent);&#10;      return NextResponse.json(programData);&#10;    } catch (err) {&#10;      // File doesn't exist yet, return default&#10;      return NextResponse.json({&#10;        currentWeek: null,&#10;        previousWeeks: [],&#10;      });&#10;    }&#10;  } catch (error) {&#10;    console.error(&quot;Error in get-program API:&quot;, error);&#10;    return NextResponse.json(&#10;      { error: &quot;Failed to fetch program data&quot; },&#10;      { status: 500 }&#10;    );&#10;  }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="import { NextResponse } from &quot;next/server&quot;;&#10;import { promises as fs } from &quot;fs&quot;;&#10;import path from &quot;path&quot;;&#10;&#10;export async function GET() {&#10;  try {&#10;    // Detect if running on Netlify - check multiple environment variables&#10;    const isNetlify = process.env.NETLIFY === 'true' ||&#10;                      process.env.NETLIFY_DEV === 'true' ||&#10;                      !!process.env.NETLIFY_BUILD_BASE ||&#10;                      process.env.CONTEXT !== undefined;&#10;&#10;    // Try to use Netlify Blobs first if in production or on Netlify&#10;    if (isNetlify || process.env.NODE_ENV === 'production') {&#10;      try {&#10;        const { getStore } = await import(&quot;@netlify/blobs&quot;);&#10;        const store = getStore(&quot;programs&quot;);&#10;        const programData = await store.get(&quot;current-program&quot;, { type: &quot;json&quot; });&#10;&#10;        if (!programData) {&#10;          return NextResponse.json({&#10;            currentWeek: null,&#10;            previousWeeks: [],&#10;          });&#10;        }&#10;&#10;        return NextResponse.json(programData);&#10;      } catch (blobError) {&#10;        console.error(&quot;Netlify Blobs read error:&quot;, blobError);&#10;        // Fall through to file system&#10;      }&#10;    }&#10;&#10;    // Fallback: Use file system (for local development or if Blobs fails)&#10;    const dataPath = path.join(process.cwd(), &quot;data&quot;, &quot;program.json&quot;);&#10;&#10;    try {&#10;      const fileContent = await fs.readFile(dataPath, &quot;utf-8&quot;);&#10;      const programData = JSON.parse(fileContent);&#10;      return NextResponse.json(programData);&#10;    } catch (_err) {&#10;      // File doesn't exist yet, return default&#10;      return NextResponse.json({&#10;        currentWeek: null,&#10;        previousWeeks: [],&#10;      });&#10;    }&#10;  } catch (error) {&#10;    console.error(&quot;Error in get-program API:&quot;, error);&#10;    return NextResponse.json(&#10;      { error: &quot;Failed to fetch program data&quot; },&#10;      { status: 500 }&#10;    );&#10;  }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/update-program/route.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/update-program/route.ts" />
              <option name="originalContent" value="import { NextRequest, NextResponse } from &quot;next/server&quot;;&#10;import { promises as fs } from &quot;fs&quot;;&#10;import path from &quot;path&quot;;&#10;&#10;export async function POST(request: NextRequest) {&#10;  try {&#10;    console.log(&quot;Update program API called&quot;);&#10;&#10;    // Check authentication&#10;    const authHeader = request.headers.get(&quot;Authorization&quot;);&#10;    const adminPassword = process.env.ADMIN_PASSWORD;&#10;&#10;    console.log(&quot;Auth header present:&quot;, !!authHeader);&#10;    console.log(&quot;Admin password configured:&quot;, !!adminPassword);&#10;&#10;    if (!adminPassword) {&#10;      console.log(&quot;ADMIN_PASSWORD not configured&quot;);&#10;      return NextResponse.json({ error: &quot;Server configuration error&quot; }, { status: 500 });&#10;    }&#10;&#10;    if (!authHeader || authHeader !== `Bearer ${adminPassword}`) {&#10;      console.log(&quot;Authorization failed&quot;);&#10;      return NextResponse.json({ error: &quot;Unauthorized&quot; }, { status: 401 });&#10;    }&#10;&#10;    console.log(&quot;Authorization successful&quot;);&#10;    const programData = await request.json();&#10;    console.log(&quot;Program data received:&quot;, Object.keys(programData));&#10;&#10;    // In production on Netlify, use Netlify Blobs&#10;    if (process.env.NETLIFY) {&#10;      console.log(&quot;Running on Netlify - using Blobs&quot;);&#10;      const { getStore } = await import(&quot;@netlify/blobs&quot;);&#10;      const store = getStore(&quot;programs&quot;);&#10;&#10;      await store.set(&quot;current-program&quot;, JSON.stringify(programData), {&#10;        metadata: {&#10;          updatedAt: new Date().toISOString(),&#10;        },&#10;      });&#10;&#10;      return NextResponse.json({&#10;        success: true,&#10;        message: &quot;Program updated successfully&quot;,&#10;      });&#10;    }&#10;&#10;    // For local development, use file system&#10;    console.log(&quot;Running locally - using file system&quot;);&#10;    const dataDir = path.join(process.cwd(), &quot;data&quot;);&#10;    const dataPath = path.join(dataDir, &quot;program.json&quot;);&#10;&#10;    console.log(&quot;Data path:&quot;, dataPath);&#10;&#10;    // Create data directory if it doesn't exist&#10;    try {&#10;      await fs.mkdir(dataDir, { recursive: true });&#10;      console.log(&quot;Data directory created/verified&quot;);&#10;    } catch {&#10;      // Directory might already exist&#10;      console.log(&quot;Data directory already exists&quot;);&#10;    }&#10;&#10;    // Write the data to file&#10;    await fs.writeFile(dataPath, JSON.stringify(programData, null, 2));&#10;    console.log(&quot;Data written successfully&quot;);&#10;&#10;    return NextResponse.json({&#10;      success: true,&#10;      message: &quot;Program updated successfully (local dev mode)&quot;,&#10;    });&#10;  } catch (error) {&#10;    console.error(&quot;Error in update-program API:&quot;, error);&#10;    const errorMessage = error instanceof Error ? error.message : &quot;Unknown error&quot;;&#10;    return NextResponse.json(&#10;      { error: &quot;Failed to update program data&quot;, details: errorMessage },&#10;      { status: 500 }&#10;    );&#10;  }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="import { NextRequest, NextResponse } from &quot;next/server&quot;;&#10;import { promises as fs } from &quot;fs&quot;;&#10;import path from &quot;path&quot;;&#10;&#10;export async function POST(request: NextRequest) {&#10;  try {&#10;    console.log(&quot;Update program API called&quot;);&#10;&#10;    // Check authentication&#10;    const authHeader = request.headers.get(&quot;Authorization&quot;);&#10;    const adminPassword = process.env.ADMIN_PASSWORD;&#10;&#10;    console.log(&quot;Auth header present:&quot;, !!authHeader);&#10;    console.log(&quot;Admin password configured:&quot;, !!adminPassword);&#10;&#10;    if (!adminPassword) {&#10;      console.log(&quot;ADMIN_PASSWORD not configured&quot;);&#10;      return NextResponse.json({ error: &quot;Server configuration error&quot; }, { status: 500 });&#10;    }&#10;&#10;    if (!authHeader || authHeader !== `Bearer ${adminPassword}`) {&#10;      console.log(&quot;Authorization failed&quot;);&#10;      return NextResponse.json({ error: &quot;Unauthorized&quot; }, { status: 401 });&#10;    }&#10;&#10;    console.log(&quot;Authorization successful&quot;);&#10;    const programData = await request.json();&#10;    console.log(&quot;Program data received:&quot;, Object.keys(programData));&#10;&#10;    // Detect if running on Netlify - check multiple environment variables&#10;    const isNetlify = process.env.NETLIFY === 'true' || &#10;                      process.env.NETLIFY_DEV === 'true' ||&#10;                      !!process.env.NETLIFY_BUILD_BASE ||&#10;                      process.env.CONTEXT !== undefined;&#10;&#10;    console.log(&quot;Environment check:&quot;, {&#10;      NETLIFY: process.env.NETLIFY,&#10;      NETLIFY_DEV: process.env.NETLIFY_DEV,&#10;      CONTEXT: process.env.CONTEXT,&#10;      isNetlify&#10;    });&#10;&#10;    // Try to use Netlify Blobs first if available&#10;    if (isNetlify || process.env.NODE_ENV === 'production') {&#10;      try {&#10;        console.log(&quot;Attempting to use Netlify Blobs&quot;);&#10;        const { getStore } = await import(&quot;@netlify/blobs&quot;);&#10;        const store = getStore(&quot;programs&quot;);&#10;&#10;        await store.set(&quot;current-program&quot;, JSON.stringify(programData), {&#10;          metadata: {&#10;            updatedAt: new Date().toISOString(),&#10;          },&#10;        });&#10;&#10;        console.log(&quot;Successfully saved to Netlify Blobs&quot;);&#10;        return NextResponse.json({&#10;          success: true,&#10;          message: &quot;Program updated successfully&quot;,&#10;        });&#10;      } catch (blobError) {&#10;        console.error(&quot;Netlify Blobs error:&quot;, blobError);&#10;        // Fall through to file system if Blobs fails&#10;      }&#10;    }&#10;&#10;    // Fallback: Use file system (for local development or if Blobs fails)&#10;    console.log(&quot;Using file system fallback&quot;);&#10;    const dataDir = path.join(process.cwd(), &quot;data&quot;);&#10;    const dataPath = path.join(dataDir, &quot;program.json&quot;);&#10;&#10;    console.log(&quot;Data path:&quot;, dataPath);&#10;&#10;    // Create data directory if it doesn't exist&#10;    try {&#10;      await fs.mkdir(dataDir, { recursive: true });&#10;      console.log(&quot;Data directory created/verified&quot;);&#10;    } catch (dirError) {&#10;      console.log(&quot;Directory creation error (might already exist):&quot;, dirError);&#10;    }&#10;&#10;    // Write the data to file&#10;    await fs.writeFile(dataPath, JSON.stringify(programData, null, 2));&#10;    console.log(&quot;Data written successfully to file system&quot;);&#10;&#10;    return NextResponse.json({&#10;      success: true,&#10;      message: &quot;Program updated successfully (file system)&quot;,&#10;    });&#10;  } catch (error) {&#10;    console.error(&quot;Error in update-program API:&quot;, error);&#10;    const errorMessage = error instanceof Error ? error.message : &quot;Unknown error&quot;;&#10;    return NextResponse.json(&#10;      { error: &quot;Failed to update program data&quot;, details: errorMessage },&#10;      { status: 500 }&#10;    );&#10;  }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/api/upload-image/route.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/api/upload-image/route.ts" />
              <option name="originalContent" value="import { NextRequest, NextResponse } from &quot;next/server&quot;;&#10;import { promises as fs } from &quot;fs&quot;;&#10;import path from &quot;path&quot;;&#10;&#10;export async function POST(request: NextRequest) {&#10;  try {&#10;    console.log(&quot;Upload image API called&quot;);&#10;&#10;    // Check authentication&#10;    const authHeader = request.headers.get(&quot;Authorization&quot;);&#10;    const adminPassword = process.env.ADMIN_PASSWORD;&#10;&#10;    console.log(&quot;Auth header present:&quot;, !!authHeader);&#10;    console.log(&quot;Admin password configured:&quot;, !!adminPassword);&#10;&#10;    if (!adminPassword) {&#10;      console.log(&quot;ADMIN_PASSWORD not configured&quot;);&#10;      return NextResponse.json({ error: &quot;Server configuration error&quot; }, { status: 500 });&#10;    }&#10;&#10;    if (!authHeader || authHeader !== `Bearer ${adminPassword}`) {&#10;      console.log(&quot;Authorization failed&quot;);&#10;      return NextResponse.json({ error: &quot;Unauthorized&quot; }, { status: 401 });&#10;    }&#10;&#10;    console.log(&quot;Authorization successful&quot;);&#10;    const formData = await request.formData();&#10;    const file = formData.get(&quot;file&quot;) as File;&#10;&#10;    if (!file) {&#10;      console.log(&quot;No file provided&quot;);&#10;      return NextResponse.json({ error: &quot;No file provided&quot; }, { status: 400 });&#10;    }&#10;&#10;    console.log(&quot;File received:&quot;, file.name, file.type, file.size);&#10;    const fileName = `${Date.now()}-${file.name}`;&#10;    const arrayBuffer = await file.arrayBuffer();&#10;&#10;    // In production on Netlify, use Netlify Blobs&#10;    if (process.env.NETLIFY) {&#10;      console.log(&quot;Running on Netlify - using Blobs&quot;);&#10;      const { getStore } = await import(&quot;@netlify/blobs&quot;);&#10;      const store = getStore(&quot;program-images&quot;);&#10;&#10;      await store.set(fileName, arrayBuffer, {&#10;        metadata: {&#10;          contentType: file.type,&#10;          uploadedAt: new Date().toISOString(),&#10;        },&#10;      });&#10;&#10;      const imageUrl = `/api/images/${fileName}`;&#10;      return NextResponse.json({ success: true, imageUrl });&#10;    }&#10;&#10;    // For local development, save to public folder&#10;    console.log(&quot;Running locally - saving to public/uploads&quot;);&#10;    const uploadsDir = path.join(process.cwd(), &quot;public&quot;, &quot;uploads&quot;);&#10;    const filePath = path.join(uploadsDir, fileName);&#10;&#10;    console.log(&quot;Upload path:&quot;, filePath);&#10;&#10;    // Create uploads directory if it doesn't exist&#10;    try {&#10;      await fs.mkdir(uploadsDir, { recursive: true });&#10;      console.log(&quot;Uploads directory created/verified&quot;);&#10;    } catch {&#10;      // Directory might already exist&#10;      console.log(&quot;Uploads directory already exists&quot;);&#10;    }&#10;&#10;    // Write the file&#10;    const buffer = Buffer.from(arrayBuffer);&#10;    await fs.writeFile(filePath, buffer);&#10;    console.log(&quot;File written successfully&quot;);&#10;&#10;    const imageUrl = `/uploads/${fileName}`;&#10;    return NextResponse.json({&#10;      success: true,&#10;      imageUrl,&#10;      note: &quot;Local dev mode - saved to /public/uploads&quot;,&#10;    });&#10;  } catch (error) {&#10;    console.error(&quot;Error in upload-image API:&quot;, error);&#10;    const errorMessage = error instanceof Error ? error.message : &quot;Unknown error&quot;;&#10;    return NextResponse.json(&#10;      { error: &quot;Failed to upload image&quot;, details: errorMessage },&#10;      { status: 500 }&#10;    );&#10;  }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="import { NextRequest, NextResponse } from &quot;next/server&quot;;&#10;import { promises as fs } from &quot;fs&quot;;&#10;import path from &quot;path&quot;;&#10;&#10;export async function POST(request: NextRequest) {&#10;  try {&#10;    console.log(&quot;Upload image API called&quot;);&#10;&#10;    // Check authentication&#10;    const authHeader = request.headers.get(&quot;Authorization&quot;);&#10;    const adminPassword = process.env.ADMIN_PASSWORD;&#10;&#10;    console.log(&quot;Auth header present:&quot;, !!authHeader);&#10;    console.log(&quot;Admin password configured:&quot;, !!adminPassword);&#10;&#10;    if (!adminPassword) {&#10;      console.log(&quot;ADMIN_PASSWORD not configured&quot;);&#10;      return NextResponse.json({ error: &quot;Server configuration error&quot; }, { status: 500 });&#10;    }&#10;&#10;    if (!authHeader || authHeader !== `Bearer ${adminPassword}`) {&#10;      console.log(&quot;Authorization failed&quot;);&#10;      return NextResponse.json({ error: &quot;Unauthorized&quot; }, { status: 401 });&#10;    }&#10;&#10;    console.log(&quot;Authorization successful&quot;);&#10;    const formData = await request.formData();&#10;    const file = formData.get(&quot;file&quot;) as File;&#10;&#10;    if (!file) {&#10;      console.log(&quot;No file provided&quot;);&#10;      return NextResponse.json({ error: &quot;No file provided&quot; }, { status: 400 });&#10;    }&#10;&#10;    console.log(&quot;File received:&quot;, file.name, file.type, file.size);&#10;    const fileName = `${Date.now()}-${file.name}`;&#10;    const arrayBuffer = await file.arrayBuffer();&#10;&#10;    // Detect if running on Netlify - check multiple environment variables&#10;    const isNetlify = process.env.NETLIFY === 'true' || &#10;                      process.env.NETLIFY_DEV === 'true' ||&#10;                      !!process.env.NETLIFY_BUILD_BASE ||&#10;                      process.env.CONTEXT !== undefined;&#10;&#10;    console.log(&quot;Environment check:&quot;, {&#10;      NETLIFY: process.env.NETLIFY,&#10;      NETLIFY_DEV: process.env.NETLIFY_DEV,&#10;      CONTEXT: process.env.CONTEXT,&#10;      isNetlify&#10;    });&#10;&#10;    // Try to use Netlify Blobs first if available&#10;    if (isNetlify || process.env.NODE_ENV === 'production') {&#10;      try {&#10;        console.log(&quot;Attempting to use Netlify Blobs for image storage&quot;);&#10;        const { getStore } = await import(&quot;@netlify/blobs&quot;);&#10;        const store = getStore(&quot;program-images&quot;);&#10;&#10;        await store.set(fileName, arrayBuffer, {&#10;          metadata: {&#10;            contentType: file.type,&#10;            uploadedAt: new Date().toISOString(),&#10;          },&#10;        });&#10;&#10;        const imageUrl = `/api/images/${fileName}`;&#10;        console.log(&quot;Successfully saved to Netlify Blobs&quot;);&#10;        return NextResponse.json({ success: true, imageUrl });&#10;      } catch (blobError) {&#10;        console.error(&quot;Netlify Blobs error:&quot;, blobError);&#10;        // Fall through to file system if Blobs fails&#10;      }&#10;    }&#10;&#10;    // Fallback: Use local file system&#10;    console.log(&quot;Using file system fallback - saving to public/uploads&quot;);&#10;    const uploadsDir = path.join(process.cwd(), &quot;public&quot;, &quot;uploads&quot;);&#10;    const filePath = path.join(uploadsDir, fileName);&#10;&#10;    console.log(&quot;Upload path:&quot;, filePath);&#10;&#10;    // Create uploads directory if it doesn't exist&#10;    try {&#10;      await fs.mkdir(uploadsDir, { recursive: true });&#10;      console.log(&quot;Uploads directory created/verified&quot;);&#10;    } catch {&#10;      // Directory might already exist&#10;      console.log(&quot;Uploads directory already exists&quot;);&#10;    }&#10;&#10;    // Write the file&#10;    const buffer = Buffer.from(arrayBuffer);&#10;    await fs.writeFile(filePath, buffer);&#10;    console.log(&quot;File written successfully&quot;);&#10;&#10;    const imageUrl = `/uploads/${fileName}`;&#10;    return NextResponse.json({&#10;      success: true,&#10;      imageUrl,&#10;      note: &quot;Saved to file system - /public/uploads&quot;,&#10;    });&#10;  } catch (error) {&#10;    console.error(&quot;Error in upload-image API:&quot;, error);&#10;    const errorMessage = error instanceof Error ? error.message : &quot;Unknown error&quot;;&#10;    return NextResponse.json(&#10;      { error: &quot;Failed to upload image&quot;, details: errorMessage },&#10;      { status: 500 }&#10;    );&#10;  }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>